# ATN model
# returns abundance over time generated by a dynamic bioenergetic food web model
# see Williams and Martinez (2004) and Romanuk et al (2009) for model
# Williams and Martinez (2004): 10.1140/epjb/e2004-00122-1
# Romanuk et al (2009): 10.1098/rstb.2008.0286

# load packages and set WD to source file location
library(tidyverse)
library(igraph)
library(deSolve)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("../Niche/niche.R") # source helper functions from niche.R

#-----------------------------------------------------------------------------#

# get_dB(): function to calculate dBi/dt for all species i given the time, a vector of biomasses, and a list of model parameters
# input: integer t, vector of length S for positive integer S, list of length 7
# output: list of length S
# see deSolve package documentation for specifications of function to be used with ODE solver
get_dB <- function(t, state, parameters) {
  # extract parameters from list of model parameters
  r <- parameters$r
  K <- parameters$K
  x <- parameters$x
  y <- parameters$y
  e <- parameters$e
  B0 <- parameters$B0
  q <- parameters$q
  
  # get number of species in web
  S <- nrow(adjacency_matrix)
  
  # if a species' biomass fell below the extinction threshold, set its biomass to 0
  threshold <- 1*10^(-10)
  state <- ifelse(state < threshold, 0, state)
  
  # calculate primary production vector
  primary_production <- r*state*(1-state/K)
  
  # Calculate metabolic loss vector
  metabolic_loss <- x*state
  
  # calculate resource gain and consumer loss vectors
  resource_gain <- rep(0, S) # initiate a vector to store resource gain for each species
  consumer_loss <- rep(0, S) # initiate a vector to store consumer loss for each species
  
  for (i in 1:S) {
    # calculate resource_gain
    b_sum_i <- as.vector(state^(1+q) %*% adjacency_matrix[i,])
    F_ij <- (state^(1+q))/(b_sum_i + B0[i,]^(1+q))
    resource_gain[i] <- (x[i]*y[i,]*F_ij*state[i]) %*% adjacency_matrix[i,]
    
    # calculate consumer_loss
    b_sum_j <- t(adjacency_matrix %*% state^(1+q))
    F_ji <- state[i]^(1+q)/(b_sum_j + B0[,i]^(1+q))
    consumer_loss[i] <- (x*y[,i]*F_ji*state/e[,i]) %*% adjacency_matrix[,i]
  }
  
  # sum the above components and store in dBdt
  dBdt <- primary_production - metabolic_loss + resource_gain - consumer_loss
  
  return(list(dBdt))
}

# analyze_web(): run simulation on web described at given file path
# input: .csv file with web details (column 1 'S': species ID;
#                                    column 2 'n': niche value;
#                                    column 3 'r': niche range;
#                                    column 4 'c': niche range center;
#                                    column 5 'b': biomass)
# output: dataframe of biomasses at end of simulation
analyze_web <- function(web_details_file) {
  start_time <- Sys.time()
  
  # read and store web details
  details <- read.csv(web_details_file, header = TRUE)
  species_IDs <- details[,1] # store species IDs for web
  web_pars <- details[,2:4] # store species parameters for web
  biomasses <- details[,5] # store species biomasses for web
  
  # construct adjacency matrix for web, set globally within function for get_dB() to use
  adjacency_matrix <<- make_Adj(web_pars)
  S <- nrow(adjacency_matrix) # get initial number of species in web
  
  # set parameters
  r <- ifelse(rowSums(adjacency_matrix) == 0, 1, 0)
  K <- rep(1, S)
  x <- rep(0.5, S)
  y <- matrix(rep(6, S^2), nrow = S, ncol = S)
  e <- matrix(rep(1, S^2), nrow = S, ncol = S)
  B0 <- matrix(rep(0.5, S^2), nrow = S, ncol = S)
  q <- 0.2
  
  # set parameter list
  pars <- list(r = r, K = K, x = x, y = y, e = e, B0 = B0, q = q)
  # set time vector
  times <- seq(1, 2000, 1)
  # set initial biomass vector
  initial_state <- biomasses
  
  # run simulation on web and store output as dataframe
  # see deSolve package documentation for arguments requirements of ODE solver function ode()
  simulation_df <- as.data.frame(ode(initial_state, times, get_dB, pars, method = "ode45"))
  simulation_df <- simulation_df[, 2:ncol(simulation_df)]
  
  # extract final biomasses from simulation dataframe
  b <- as.numeric(as.vector(t(simulation_df[nrow(simulation_df),])))
  S <- as.numeric(as.vector(t(species_IDs)))
  b_final <- as.data.frame(cbind(S, b))
  
  # prune web of species falling below biomass threshold
  threshold <- 1*10^(-10)
  output <- b_final[b_final$b > threshold,]
  
  end_time <- Sys.time()
  print(end_time - start_time)
  return(output)
}