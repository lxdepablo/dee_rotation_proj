# Revised ATN model for testing Lucy's code
# returns abundance over time generated by a dynamic bioenergetic food web model with S initial species
# see Williams and Martinez (2004) and Romanuk et al (2009) for model
# Williams and Martinez (2004): 10.1140/epjb/e2004-00122-1
# Romanuk et al (2009): 10.1098/rstb.2008.0286

# load packages and set WD to source file location
library(tidyverse)
library(igraph)
library(deSolve)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("ATN/static_models.R")

#-----------------------------------------------------------------------------#

# get_dB(): function to calculate dBi/dt for all species i given the time, initial biomasses, and model parameters
# input: integer t, vector of length S for positive integer S, vector of length 7
# output: list of length S
get_dB <- function(t, state, parameters) {
  #adjacency_matrix <- parameters[["adjacency_matrix"]]
  with(as.list(c(state, parameters)), {
    S <- length(state) # get number of species in web
    dBdt <- rep(0,S) # create vector to store dBi for all i
    
    # zero out all species whose biomasses went negative after the previous step
    for (i in 1:S) {
      if (state[i] < 0) {
        state[i] <- 0
      }
    }
    
    # calculate dBi/dt for all i and store in dBdt
    for (i in 1:S) {
      # determine whether species i is basal and set intrinsic growth rate r accordingly
      if (sum(adjacency_matrix[i,]) == 0) {
        r <- 1 # set r to 1 if species i is basal
      }
      else {r <- 0} # otherwise set r to 0
      
      # get resource vector, the species that i eats
      resources <- which(adjacency_matrix[i,] == 1)
      
      # get consumer vector, the species that eat i
      consumers <- which(adjacency_matrix[,i] == 1)
      
      # calculate primary production
      primary_production <- r*state[i]*(1-(state[i]/K))
      
      # calculate metabolic loss
      metabolic_loss <- x*state[i]
      
      # calculate resource_gain
      resource_gain <- 0 # start by setting resource_gain to 0
      for (j in resources) {
        # calculate Fij
        b_sum <- 0
        for (k in resources) { # sum Bk^(1+q) for every k that i eats
          b_sum <- b_sum + (state[k])^(1+q)
        }
        Fij <- ((state[j])^(1+q))/(b_sum + B0^(1+q))
        
        # calculate gain from resource j
        resource_gain_j <- x*y*Fij*state[i]
        
        # add resource_gain_j to resource_gain
        resource_gain <- resource_gain + resource_gain_j
      }
      
      # calculate consumer_loss
      consumer_loss <- 0 # start by setting consumer_loss to 0
      for (j in consumers) {
        # calculate Fji
        j_resources <- which(adjacency_matrix[j,] == 1)
        b_sum <- 0
        for (k in j_resources) { #sum Bk^(1+q) for every k that j eats
          b_sum <- b_sum + (state[k])^(1+q)
        }
        Fji <- ((state[i])^(1+q))/(b_sum + B0^(1+q))
        
        # calculate loss to consumer j
        consumer_loss_j <- x*y*Fji*state[j]/e
        
        # add consumer_loss_j to consumer_loss
        consumer_loss <- consumer_loss + consumer_loss_j
      }
      
      # sum the above components and store in dBdt[i]
      dBdt[i] <- primary_production - metabolic_loss + resource_gain - consumer_loss
    }
    return(list(dBdt))
  })
}

# analyze_web(): run simulation on web and get relevant output for comparison
# input: csv file with web details
# output: list of outputs
analyze_web <- function(web_details_file) {
  start_time <- Sys.time()
  
  details <- read.csv(web_details_file, header = TRUE) # read in dataframe of web details
  web_pars <- details[,2:4] # store species parameters for web
  species_IDs <- details[,1] # store species IDs for web
  
  # construct adjacency matrix for web, set globally within function for get_dB() to use
  adjacency_matrix <<- make_Adj(web_pars)
  
  # set parameter vector pars = (K, x, y, e, B0, q) according to values used by Romanuk et al (2009)
  pars <<- c(K=1,x=0.5,y=6,e=1,B0=0.5,q=0.2, adjacency_matrix = canoe_beach_adj_mat)
  # set time vector times = (1,...,2000)
  times <<- seq(1,2000,1)
  # set initial biomass vector
  initial_state <<- details[['b']]
  
  # run simulation on web and store output as dataframe
  simulation_df <- as.data.frame(ode(initial_state, times, get_dB, pars, method = "ode45"))
  simulation_df <- simulation_df[, 2:ncol(simulation_df)]
  colnames(simulation_df) <- species_IDs
  
  # extract final biomasses from simulation dataframe and prune web
  b <- as.numeric(as.vector(t(simulation_df[nrow(simulation_df),])))
  S <- as.numeric(as.vector(t(colnames(simulation_df))))
  b_final <- as.data.frame(cbind(S, b))
  
  threshold <- 1*10^(-10)
  output <- b_final[b_final$b > threshold,]
  
  end_time <- Sys.time()
  print(end_time - start_time)
  return(output)
}

# test_web_path <- "./problem_webs/web_0_inv_346_details.csv"
# test_web_details <- read.csv(test_web_path, header = TRUE)
# test_web_pars <- test_web_details[,2:4]
# adjacency_matrix <<- make_Adj(test_web_pars)
# pars <<- c(K=1,x=0.5,y=6,e=1,B0=0.5,q=0.2)
# times <<- seq(1,2000,1)
# test_initial_state <<- test_web_details[['b']]
# test_dB_1 <- get_dB(1, test_initial_state, pars)
